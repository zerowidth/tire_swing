module TireSwing

  # TireSwing nodes are auto-generated by node definitions (see TireSwing::NodeDefinition).
  # A node is meant to be a part of an AST external to the AST that Treetop generates at parse-time
  # with Treetop::Runtime::SyntaxNodes.
  #
  class Node

    # Create a subclass of Node with the given attributes, both simple and mapped.
    #
    # (see NodeDefinitions#node for more information)
    #
    def self.create(*attribs)
      Class.new(self) do
        attribs.each do |attrib|
          case attrib
          when Symbol, String
            add_mapping(attrib, attrib)
          when Hash
            attrib.each { |name, symbol| add_mapping(name, symbol) }
          end
        end
      end
    end

    # The mapping of attribute names to the auto-build values/methods/lambdas used by create_node
    def self.attribute_mapping
      @attribute_mapping ||= {}
    end

    def self.add_mapping(name, value)
      attribute(name.to_s) { raise "no value given for #{name}" }
      attribute_mapping[name.to_s] = value
    end

    # keep track of where this node lives in the tree
    attr_accessor :parent

    # Instantiate a node.
    #
    # Values can either be a hash of values to set the values of this node's attributes, or a Treetop syntax node
    # which is used to automatically build this node.
    #
    def initialize(values={})
      if values.kind_of?(Treetop::Runtime::SyntaxNode)
        build_from_parsed_node(values)
      else
        values.each do |name, value|
          send("#{name}=", value)
        end
      end
    end

    # Deep-copy of this node and any children. Use this if you need to manipulate an AST without modifying the original
    def clone
      Marshal.load(Marshal.dump(self))
    end

    protected

    # Auto-builds this node using the provided parsed node and the defined attributes and mapped attributes.
    def build_from_parsed_node(node)
      attributes.each do |attrib|
        value = apply_mapping(attrib, node)

        value = if value.kind_of?(Array)
          value.map { |val| extract_value(val) }
        else
          extract_value(value)
        end

        send("#{attrib}=", value)
      end
    end

    def apply_mapping(attrib, node)
      handler = mapping_for(attrib)

      if handler.kind_of?(Proc)
        value = handler.call(node)
      else
        send_handler_method handler, node
      end

    end

    def send_handler_method(handler, node)
      if node.respond_to?(handler)
        value = node.send(handler)
      else
        value = node.text_value.send(handler)
      end
    rescue NoMethodError
      context = node.text_value.split("\n")
      context = context.size > 1 ? context.first + "..." : context
      raise ParseError,
        %Q{expected node containing "#{context}" or its text value to respond to  #{handler.inspect}}
    end

    def extract_value(value)
      if value.respond_to?(:build)
        node = value.build
        node.parent = self if node.kind_of?(Node)
        node
      elsif value.kind_of?(Treetop::Runtime::SyntaxNode)
        value.text_value
      else
        value
      end
    end

    def attributes
      self.class.attributes
    end

    def mapping_for(name)
      self.class.attribute_mapping[name]
    end

  end

end
